<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Silent Shadows (Side-Scroller Prototype)</title>
<style>
  html,body{margin:0;padding:0;background:#161616;color:#e9e4d6;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  #wrap{max-width:1000px;margin:20px auto;padding:0 12px}
  h1{font-size:18px;margin:8px 0 10px;letter-spacing:.4px}
  .hud{font-size:13px;opacity:.9;line-height:1.35}
  .kbd{padding:2px 6px;border:1px solid #666;border-bottom-width:2px;border-radius:4px;background:#222;color:#eee;font-family:Menlo,Consolas,monospace;font-size:12px}
  canvas{width:100%;height:auto;display:block;border:1px solid #333;border-radius:10px;background:#d7c7a1}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin:10px 0 8px}
  button{background:#262626;border:1px solid #3a3a3a;color:#e9e4d6;padding:6px 10px;border-radius:8px;cursor:pointer}
</style>
</head>
<body>
<div id="wrap">
  <h1>Silent Shadows — Side-Scroller Prototype</h1>
  <div class="row">
    <div class="hud">
      <div>
        <span class="kbd">A/D</span> move • <span class="kbd">W</span> jump • <span class="kbd">Shift</span> sneak •
        <span class="kbd">Space</span> close/open eyes • <span class="kbd">E</span> toss decoy goggles
      </div>
      <div>Blend rule: only blends when you are <b>standing still</b> inside a darker “blend” strip.</div>
    </div>
    <button id="reset">Reset</button>
  </div>
  <canvas id="c" width="960" height="540"></canvas>
</div>

<script>
(() => {
  const W=960,H=540;
  const ctx = document.getElementById('c').getContext('2d');
  const keys = Object.create(null);
  addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);
  addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);
  document.getElementById('reset').onclick = reset;

  // Tuning
  const GRAV=0.65, JUMP=-11.5;
  const RUN=3.1, SNEAK=1.6, BOLD=3.8;
  const ALERT_TIME=1700;
  const DECOY_DURATION=3000;
  const MAX_GOGGLES=2;
  const PING_DURATION=1600;

  const GUARD_VIEW=240;
  const GUARD_FOV=Math.PI*0.38;
  const GUARD_SPEED=1.15;
  const INVEST_SPEED=1.85;
  const SEARCH_TIME=1200;
  const SEARCH_SWEEP=0.0022;

  // Simple AABB
  const aabb=(x,y,w,h)=>({x,y,w,h});
  const hit=(a,b)=>a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;

  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function hypot(x,y){return Math.hypot(x,y);}
  function ang(ax,ay,bx,by){return Math.atan2(by-ay,bx-ax);}
  function inCone(px,py,gx,gy,face,fov,dist){
    const dx=px-gx, dy=py-gy;
    if(dx*dx+dy*dy>dist*dist) return false;
    const a=Math.atan2(dy,dx);
    const diff=Math.atan2(Math.sin(a-face),Math.cos(a-face));
    return Math.abs(diff)<=fov*0.5;
  }

  function hasLOS(ax,ay,bx,by, solids){
    const steps = Math.ceil(Math.hypot(bx-ax,by-ay)/6);
    for(let i=0;i<=steps;i++){
      const t=i/steps;
      const x=ax+(bx-ax)*t, y=ay+(by-ay)*t;
      const p=aabb(x-1,y-1,2,2);
      for(const s of solids){
        if(hit(p,aabb(s.x,s.y,s.w,s.h))) return false;
      }
    }
    return true;
  }

  let S;
  function reset(){
    // Level is built in world coords, camera follows player
    S = {
      t:0,
      win:false, lose:false,
      eyesClosed:false,
      lastMoveT:0,
      seen:0,
      goggles:MAX_GOGGLES,
      decoys:[], // {x,y,created}
      ping:null, // {x,y,created}
      camX:0,
      player:{
        x:80,y:320,w:18,h:34,
        vx:0,vy:0,onGround:false,
        facing:0 // 0 right, PI left
      },
      exit:{x:2650,y:280,w:40,h:70},
      // Colliders (platforms/walls) – all solid
      solids:[
        {x:0,y:420,w:2900,h:120},
        {x:260,y:360,w:220,h:28},
        {x:560,y:310,w:260,h:26},
        {x:920,y:380,w:200,h:26},
        {x:1180,y:330,w:240,h:26},
        {x:1500,y:280,w:240,h:26},
        {x:1780,y:360,w:260,h:26},
        {x:2100,y:320,w:260,h:26},
        {x:2350,y:380,w:220,h:26},
        // blockers
        {x:720,y:220,w:26,h:220},
        {x:1640,y:220,w:26,h:220},
        {x:2460,y:220,w:26,h:220},
      ],
      // Blend strips (not solid)
      blend:[
        {x:520,y:392,w:220,h:28},
        {x:1180,y:412,w:240,h:28},
        {x:1760,y:332,w:240,h:28},
        {x:2300,y:412,w:220,h:28},
      ],
      guards:[
        // patrol between x1..x2 on their current platform Y
        {x:640,y:285,w:20,h:38, x1:520,x2:800, dir:1, facing:0, mode:"patrol", timer:0},
        {x:1520,y:255,w:20,h:38, x1:1500,x2:1740, dir:-1,facing:Math.PI, mode:"patrol", timer:0},
        {x:2200,y:295,w:20,h:38, x1:2100,x2:2360, dir:1, facing:0, mode:"patrol", timer:0},
      ]
    };
  }
  reset();

  function tossDecoy(){
    if(S.goggles<=0) return;
    S.goggles--;
    const p=S.player;
    const dx=Math.cos(p.facing), dy=Math.sin(p.facing);
    const d=140;
    // "Stick to wall": we just place at target point; in Unity you can raycast to nearest wall.
    const x = clamp(p.x + dx*d, 20, 2880);
    const y = clamp(p.y - 20, 40, 480);
    S.decoys.push({x,y,created:S.t});
    S.eyesClosed=true; // auto-close
  }

  function resolvePlayerSolids(){
    const p=S.player;
    // X
    p.x += p.vx;
    let box=aabb(p.x-p.w/2,p.y-p.h/2,p.w,p.h);
    for(const s of S.solids){
      const sb=aabb(s.x,s.y,s.w,s.h);
      if(hit(box,sb)){
        if(p.vx>0) p.x = sb.x - p.w/2;
        if(p.vx<0) p.x = sb.x + sb.w + p.w/2;
        box=aabb(p.x-p.w/2,p.y-p.h/2,p.w,p.h);
      }
    }
    // Y
    p.y += p.vy;
    p.onGround=false;
    box=aabb(p.x-p.w/2,p.y-p.h/2,p.w,p.h);
    for(const s of S.solids){
      const sb=aabb(s.x,s.y,s.w,s.h);
      if(hit(box,sb)){
        if(p.vy>0){ // falling
          p.y = sb.y - p.h/2;
          p.vy=0;
          p.onGround=true;
        } else if(p.vy<0){ // rising
          p.y = sb.y + sb.h + p.h/2;
          p.vy=0;
        }
        box=aabb(p.x-p.w/2,p.y-p.h/2,p.w,p.h);
      }
    }
  }

  function update(dt){
    if(S.win||S.lose) return;
    S.t += dt;

    const p=S.player;
    const left=keys['a'], right=keys['d'], jump=keys['w'];
    const sneak=keys['shift'];

    // Toggle eyes (disabled during active decoy window)
    const decoyActive = S.decoys.some(d=>S.t-d.created<DECOY_DURATION);
    if(keys[' '] && !update._space){
      update._space=true;
      if(!decoyActive) S.eyesClosed=!S.eyesClosed;
    }
    if(!keys[' ']) update._space=false;

    if(keys['e'] && !update._e){ update._e=true; tossDecoy(); }
    if(!keys['e']) update._e=false;

    // Movement
    let moveDir = (right?1:0) - (left?1:0);
    const moving = moveDir!==0;
    if(moving) S.lastMoveT = S.t;

    let spd = RUN;
    if(decoyActive){ spd=BOLD; S.eyesClosed=true; } // bold window = no sneak
    else if(sneak) spd=SNEAK;

    p.vx = moveDir*spd;
    if(moving) p.facing = (moveDir>0)?0:Math.PI;

    // Jump
    if(jump && p.onGround && !update._jump){
      update._jump=true;
      p.vy = JUMP;
      p.onGround=false;
    }
    if(!jump) update._jump=false;

    // Gravity
    p.vy += GRAV;
    p.vy = Math.min(p.vy, 14);

    resolvePlayerSolids();

    // Camera follow
    S.camX = clamp(p.x - W*0.45, 0, 2900 - W);

    // Blend: only standing still inside blend strip
    const standingStill = (S.t - S.lastMoveT) >= 60; // require ~60ms idle
    let insideBlend=false;
    const px=p.x, py=p.y+p.h*0.25;
    for(const b of S.blend){
      if(px>=b.x && px<=b.x+b.w && py>=b.y && py<=b.y+b.h){ insideBlend=true; break; }
    }
    const blended = insideBlend && standingStill;

    // Cleanup timed targets
    S.decoys = S.decoys.filter(d=>S.t-d.created<DECOY_DURATION);
    if(S.ping && S.t - S.ping.created > PING_DURATION) S.ping=null;

    // Guard logic: decoy > ping > patrol/search
    const activeDecoys = S.decoys; // already filtered
    const pingActive = S.ping && (S.t - S.ping.created < PING_DURATION);

    for(const g of S.guards){
      let target=null;
      if(activeDecoys.length){
        // nearest decoy
        let best=1e9;
        for(const d of activeDecoys){
          const dd=hypot(d.x-g.x,d.y-g.y);
          if(dd<best){best=dd; target=d;}
        }
      } else if(pingActive){
        target=S.ping;
      }

      if(target){
        const a = ang(g.x,g.y,target.x,target.y);
        g.facing=a;
        const d=hypot(target.x-g.x,target.y-g.y);
        if(d<16){
          g.mode="search";
          g.timer=SEARCH_TIME;
        } else {
          g.mode="investigate";
          g.x += Math.cos(a)*INVEST_SPEED;
          // keep on platform y (guards slide on their lane)
          // but allow small y correction toward target for ramps later:
          g.y += Math.sin(a)*0.25;
        }
      } else {
        if(g.mode==="search"){
          g.timer -= dt;
          g.facing += (g._dir?1:-1)*SEARCH_SWEEP*dt;
          if(Math.random()<0.01) g._dir=!g._dir;
          if(g.timer<=0) g.mode="patrol";
        } else {
          g.mode="patrol";
          g.x += g.dir*GUARD_SPEED;
          if(g.x<g.x1){g.x=g.x1; g.dir=1;}
          if(g.x>g.x2){g.x=g.x2; g.dir=-1;}
          g.facing = (g.dir>0)?0:Math.PI;
        }
      }
    }

    // Detection + ping if not blended
    let spotted=false;
    const playerMoving = (S.t - S.lastMoveT) < 60;
    const eyesVisible = (!playerMoving && !S.eyesClosed);

    for(const g of S.guards){
      const canSeeMoving = playerMoving && inCone(p.x,p.y,g.x,g.y,g.facing,GUARD_FOV,GUARD_VIEW) &&
                           hasLOS(g.x,g.y,p.x,p.y,S.solids);
      const canSeeEyes = eyesVisible && hypot(p.x-g.x,p.y-g.y) < 32 &&
                         hasLOS(g.x,g.y,p.x,p.y,S.solids);

      if(canSeeMoving || canSeeEyes){
        spotted=true;
        if(!blended) S.ping = {x:p.x, y:p.y, created:S.t};
      }
    }

    if(spotted){
      S.seen += dt;
      if(S.seen > ALERT_TIME) S.lose=true;
    } else {
      S.seen = Math.max(0, S.seen - dt*0.5);
    }

    // Win
    const ex=S.exit;
    const pb=aabb(p.x-p.w/2,p.y-p.h/2,p.w,p.h);
    if(hit(pb,aabb(ex.x-ex.w/2,ex.y-ex.h/2,ex.w,ex.h))) S.win=true;

    // HUD snapshot
    S._hud={blended, decoyActive};
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // Background
    ctx.fillStyle="#d7c7a1";
    ctx.fillRect(0,0,W,H);

    // Parallax-ish background shapes (cheap poster vibe)
    const px = S.camX;
    ctx.save();
    ctx.translate(-px*0.25,0);
    ctx.fillStyle="#c2b08b";
    ctx.fillRect(120,90,280,90);
    ctx.fillRect(640,110,420,70);
    ctx.fillRect(1180,80,360,120);
    ctx.fillRect(1700,120,520,90);
    ctx.restore();

    ctx.save();
    ctx.translate(-px*0.45,0);
    ctx.fillStyle="#b59f77";
    ctx.fillRect(240,160,240,70);
    ctx.fillRect(980,150,280,90);
    ctx.fillRect(1540,170,340,70);
    ctx.fillRect(2140,150,280,90);
    ctx.restore();

    // World draw offset
    ctx.save();
    ctx.translate(-S.camX,0);

    // Blend strips
    for(const b of S.blend){
      ctx.fillStyle="#a28d64";
      ctx.fillRect(b.x,b.y,b.w,b.h);
    }

    // Solids
    for(const s of S.solids){
      ctx.fillStyle="#bda77c";
      ctx.fillRect(s.x,s.y,s.w,s.h);
    }

    // Exit
    const ex=S.exit;
    ctx.fillStyle="#232323";
    ctx.fillRect(ex.x-ex.w/2, ex.y-ex.h/2, ex.w, ex.h);
    ctx.fillStyle="#e9e4d6";
    ctx.font="12px Menlo";
    ctx.textAlign="center";
    ctx.fillText("EXIT", ex.x, ex.y+4);

    // Decoys
    for(const d of S.decoys){
      ctx.fillStyle="rgba(255,255,245,0.95)";
      ctx.fillRect(d.x-6,d.y-4,12,8);
    }

    // Player ping ring
    if(S.ping){
      const t = 1 - (S.t - S.ping.created)/PING_DURATION;
      ctx.strokeStyle = `rgba(35,35,35,${0.55*t})`;
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.arc(S.ping.x,S.ping.y, 14+14*(1-t), 0, Math.PI*2);
      ctx.stroke();
    }

    // Guards
    for(const g of S.guards){
      // Cone
      ctx.save();
      ctx.translate(g.x,g.y);
      ctx.rotate(g.facing);
      ctx.fillStyle="rgba(35,35,35,0.20)";
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,GUARD_VIEW,-GUARD_FOV/2,GUARD_FOV/2);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // Body
      ctx.fillStyle="#222";
      ctx.fillRect(g.x-g.w/2,g.y-g.h/2,g.w,g.h);
      // State indicator
      ctx.fillStyle = g.mode==="search" ? "#f0c674" : (g.mode==="investigate" ? "#c36" : "#222");
      ctx.fillRect(g.x-8,g.y-g.h/2-4,16,3);
    }

    // Player (silhouette only when moving; eyes when still & open)
    const p=S.player;
    const moving = (S.t - S.lastMoveT) < 60;
    if(moving){
      ctx.fillStyle="#111";
      ctx.fillRect(p.x-p.w/2,p.y-p.h/2,p.w,p.h);
    } else if(!S.eyesClosed){
      ctx.fillStyle="#fffdf2";
      ctx.fillRect(p.x-6,p.y-2,5,4);
      ctx.fillRect(p.x+1,p.y-2,5,4);
    }

    ctx.restore(); // world

    // Top HUD bar
    ctx.fillStyle="#161616";
    ctx.fillRect(0,0,W,30);
    ctx.fillStyle="#e9e4d6";
    ctx.font="14px Menlo";
    ctx.textAlign="left";
    ctx.fillText(`Goggles: ${S.goggles}`, 12, 19);
    ctx.fillText(`Blend: ${S._hud?.blended ? "YES" : "NO"}`, 150, 19);
    ctx.fillText(`Mode: ${S._hud?.decoyActive ? "BOLD (no sneak)" : (keys['shift'] ? "SNEAK" : "NORMAL")}`, 290, 19);

    if(S.seen>0 && !S.win && !S.lose){
      const pct=Math.min(1,S.seen/ALERT_TIME);
      ctx.fillStyle="rgba(180,40,40,0.75)";
      ctx.fillRect(W-210,9,pct*190,12);
      ctx.strokeStyle="rgba(0,0,0,0.6)";
      ctx.strokeRect(W-210,9,190,12);
      ctx.fillStyle="#e9e4d6";
      ctx.textAlign="center";
      ctx.fillText("ALERT", W-115, 20);
    }

    if(S.win||S.lose){
      ctx.fillStyle="rgba(0,0,0,0.62)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle="#e9e4d6";
      ctx.font="30px Menlo";
      ctx.textAlign="center";
      ctx.fillText(S.win ? "EXFIL SUCCESS" : "DETECTED", W/2, H/2);
      ctx.font="14px Menlo";
      ctx.fillText("Click Reset to try again", W/2, H/2+24);
    }
  }

  let last=performance.now();
  function loop(now){
    const dt=now-last; last=now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
